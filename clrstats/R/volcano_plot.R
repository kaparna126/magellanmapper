
volcanoPlot <- function(stats, meas, interaction, thresh=NULL, 
                        log.scale.x=TRUE, labels=TRUE, plot.size=c(5, 7), 
                        size.mult=3, meas.names=NULL) {
  # Generate a volcano plot.
  #
  # Args:
  #   stats: Data frame generated by \code{\link{filterStats}}.
  #   meas: Measurement to display in plot title.
  #   interaction: Interaction column name whose set of stats should be 
  #     displayed.
  #   thresh: Threshold as a 3-element array corresponding to the x, y, and  
  #     size (0-1 scale), respectively, above which labels will be shown if 
  #     all conditions are met. NA for any value will cause the threshold to 
  #     be ignored, or NA for the entire argument will ignore thresholding 
  #     all together.
  #   log.scale.x: True to scale x-axis by log10, first normalizing to 
  #     the minimum x-value before taking the log of the absolute value 
  #     to avoid negative log values, then returning to the original sign.
  #   plot.size: Vector of width, height for exported plot; defaults to 
  #     c(5, 7).
  #   size.mult: Point size multiplier; defaults to 3.
  #   meas.names: Named nested list whose sublists' first element will 
  #     specify the title, with names corresponding to meas. Defaults to 
  #     NULL to use a default title.
  
  x <- stats[[paste0(interaction, ".effect")]]
  num.x <- length(x)
  if (num.x < 1) {
    cat("no values found to generate volcano plot, skipping\n")
    return()
  }
  y <- stats[[paste0(interaction, ".logp")]]
  # weight size based on mean volume, replacing NaNs with a small num
  vol <- stats$Volume
  if (isTRUE(all.equal(vol, rep(0, num.x)))) {
    size <- rep(1, num.x)
  } else {
    vol[is.nan(vol) | vol == 0] <- 1
    size <- sqrt(vol / max(vol))
  }
  #print(data.frame(x, size))
  
  # point colors based on IDs of parents at the level generated for region 
  # IDs file, using a palette with color for each unique parent
  parents <- stats$Parent
  parents.unique <- unique(parents)
  parents.indices <- match(parents, parents.unique)
  colors <- RColorBrewer::brewer.pal(length(parents.unique), "Paired")
  colors_parents <- colors[parents.indices]
  
  # base plot -log p vs effect size
  xlab <- "Effects"
  if (log.scale.x) {
    # log scale x, rescaling so abs vals of x are >= 1 to get pos log vals 
    # and changing back to original sign
    x.neg <- x < 0
    x.norm <- x / min(abs(x))
    x.log <- log(abs(x.norm))
    x.log[x.neg] <- -1 * x.log[x.neg]
    print(data.frame(x, x.norm, x.neg, x.log, y))
    x <- x.log
    xlab <- "log(normalized effects)"
  }
  
  # x-lims based on points above y-thresh and size thresh if each are given; 
  # fall back to ignoring thresholds if no points meet criteria
  x.threshed <- x
  x.thresh <- NULL
  if (!is.na(thresh[2])) x.thresh <- y > thresh[2]
  if (!is.na(thresh[3])) x.thresh <- x.thresh & size > thresh[3]
  if (!is.null(x.thresh)) x.threshed <- x[x.thresh]
  x.max <- max(abs(x.threshed))
  if (is.infinite(x.max)) x.max <- max(abs(x))
  
  # use custom title if available from named list
  if (!is.null(meas.names) & is.element(meas, names(meas.names))) {
    # assumed to contain a sublist with title listed first
    title <- meas.names[[meas]][1]
  } else {
    title <- paste(meas, "Differences for", interaction)
  }

  # set up plot saving
  path.plot <- file.path(
    ifelse(exists("config.env"), config.env$Prefix, ".."),
    paste0("plot_volcano_", gsub("/| ", "_", title), ".pdf"))
  is.interactive <- interactive()
  if (!is.interactive) {
    # open PDF device if not in interactive mode (eg IDE or R interpreter);
    # if interactive, a screen device is opened instead and saved later
    pdf(width=plot.size[1], height=plot.size[2], file=path.plot)
  }

  # scatter plot with vertical line to denote x = 0
  plot(
    x, y, xlim=c(-1 * x.max, x.max), 
    main=title, xlab=xlab, 
    ylab="-log10(p)", type="p", las=1, pch=16, cex=(size*size.mult), 
    col=colors_parents)
  abline(v=0, lty="dashed", col=gray(0.5, 0.5))
  
  # label points
  x.lbl <- x
  y.lbl <- y
  lbls <- stats$RegionAbbr
  if (!is.null(thresh)) {
    # limit labels only to those within all thresholds, ignoring NAs
    show.lbl <- abs(x) > 0
    if (!is.na(thresh[1])) show.lbl <- abs(x) > thresh[1] & show.lbl
    if (!is.na(thresh[2])) show.lbl <- y > thresh[2] & show.lbl
    x.lbl <- x[show.lbl]
    y.lbl <- y[show.lbl]
    lbls <- lbls[show.lbl]
  }
  if (labels & length(lbls) > 0) {
    # place text labels; "text" has full overlap, "thigmophobe.labels" and 
    # "pointLabels" have varying degrees of overlap, and "addTextLabels" has 
    # the least overlap
    #text(x.lbl, y.lbl, label=lbls, cex=0.2)
    #thigmophobe.labels(x.lbl, y.lbl, label=lbls, cex=0.2)
    #pointLabel(x.lbl, y.lbl, label=lbls, cex=0.2)
    basicPlotteR::addTextLabels(
      x.lbl, y.lbl, label=lbls, cex.label=0.5, lwd=0.5)
  }

  if (is.interactive) {
    # save plot from interactive (screen) device
    printDirectly(pdf, path.plot, plot.size)
  }
}
